float4x4 mvp : WorldViewProjection;
float4x4 mv : WorldView;
float3 lightDirection = {-0.704, -0.704, 0};

float3 fogColor = float3(0.8, 0.8, 0.9);
float fogEnd = 750.0f;

sampler2D cubeTexture = sampler_state
{
   //generateMipMap = true;
   minFilter = Nearest;//LinearMipMapLinear;
   magFilter = Nearest;
};

struct VSout
{
   float4 position : POSITION;
   float2 texCoord : TEXCOORD0;
   float lightIntensity : TEXCOORD1;
   float fogFactor : TEXCOORD2;
};

VSout vs(in float4 position : POSITION, in half inNormal : NORMAL)//, in float texCoord : TEXCOORD0)
{
    VSout vout;

    vout.texCoord = float2(floor(inNormal), floor(frac(inNormal) * 2));
    float3 normal = float3(floor(frac(inNormal * 2) * 4), floor(frac(inNormal * 8) * 4), floor(frac(inNormal * 32) * 4));
    normal = normal - 1.0;

//    if (texCoord == 0.0)
//        vout.texCoord = float2(1, 1);
//    else if (texCoord == 1.0)
//        vout.texCoord = float2(1, 0);
//    else if (texCoord == 2.0)
//        vout.texCoord = float2(0, 0);
//    else// if (texCoord == 4.0)
//        vout.texCoord = float2(0, 1);
//    float3 normal = float3(0);
//    if (inNormal == 0.0)
//        normal = float3(0, 0, 1);
//    else if (inNormal == 1.0)
//        normal = float3(0, 1, 0);
//    else if (inNormal == 2.0)
//        normal = float3(1, 0, 0);
//    else if (inNormal == 4.0)
//        normal = float3(0, -1, 0);
//    else if (inNormal == 8.0)
//        normal = float3(-1, 0, 0);
//    else// if (inNormal == 16.0)
//        normal = float3(0, 0, -1);

    vout.position = mul(mvp, position);
    float fog = clamp(abs(vout.position.z), 0, fogEnd);
    fog = (fogEnd - fog) / fogEnd;
    vout.fogFactor = clamp(fog, 0, 1);
    vout.lightIntensity = dot(-lightDirection, normal) * 0.35 + 0.65;
    return vout;
}

float4 fs(in VSout v) : COLOR
{
   float4 c = tex2D(cubeTexture, v.texCoord);
   
   c.rgb = v.lightIntensity * lerp(fogColor, c.rgb, v.fogFactor);

   return c;
}

technique tech
{
   pass p0
   {
       VertexProgram = compile glslv vs();
       FragmentProgram = compile glslf fs();
   }
}

technique tech_arb
{
   pass p0
   {
       VertexProgram = compile arbvp1 vs();
       FragmentProgram = compile arbfp1 fs();
   }
}
